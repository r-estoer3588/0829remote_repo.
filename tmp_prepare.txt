                    start_time,
                    prefix="fetch",
                    batch=50,
                    log_area=log_area,
                    progress_bar=progress_bar,
                    extra_msg=(f"銘柄: {', '.join(buffer)}" if buffer else None),
                )
                buffer.clear()

    try:
        progress_bar.empty()
    except Exception:
        pass
    return data_dict


# ------------------------------
# Prepare + candidates
# ------------------------------
def prepare_backtest_data(
    strategy,
    symbols,
    system_name: str = "SystemX",
    spy_df: pd.DataFrame | None = None,
    ui_manager=None,
    **kwargs,
):
    # 1) fetch
    data_dict = fetch_data(symbols, ui_manager=ui_manager)
    if not data_dict:
        st.error("no valid data")
        return None, None, None

    # 2) indicators (delegated to strategy)
    # indicators フェーズ
    ind_phase = ui_manager.phase("indicators") if ui_manager else None
    if ind_phase:
        try:
            ind_phase.info("indicators: computing...")
        except Exception:
            pass
        ind_progress = ind_phase.progress_bar
        ind_log = ind_phase.log_area
    else:
        st.info("indicators: computing...")
        ind_progress = st.progress(0)
        ind_log = st.empty()
    start_time = time.time()
    prepared_dict = strategy.prepare_data(
        data_dict,
        progress_callback=lambda done, total: ind_progress.progress(0 if total == 0 else done / total),
        log_callback=lambda msg: ind_log.text(str(msg)),
        **kwargs,
    )
    try:
        ind_progress.empty()
    except Exception:
        pass

    # 3) candidates
    # candidates フェーズ
    cand_phase = ui_manager.phase("candidates") if ui_manager else None
    if cand_phase:
        try:
            cand_phase.info("candidates: extracting...")
        except Exception:
            pass
        cand_log = cand_phase.log_area
        cand_progress = cand_phase.progress_bar
    else:
        st.info("candidates: extracting...")
        cand_log = st.empty()
        cand_progress = st.progress(0)
    start_time = time.time()

    merged_df = None
    if system_name == "System1":
        if spy_df is None or spy_df.empty:
            st.error("System1 requires SPY data for market filter")
            return prepared_dict, None, None
        candidates_by_date, merged_df = generate_roc200_ranking_system1(
            prepared_dict,
            spy_df,
            on_progress=lambda i, total, start: log_with_progress(
                i,
                total,
                start,
                prefix="roc200",
                log_area=cand_log,
                progress_bar=cand_progress,
                unit="days",
            ),
            on_log=None,
        )
    else:
        # generic path (System2?7)
        try:
            _gc_kwargs = dict(kwargs or {})
            if system_name == "System4" and spy_df is not None:
                _gc_kwargs.setdefault("market_df", spy_df)
            candidates_by_date = strategy.generate_candidates(
                prepared_dict,
                progress_callback=lambda done, total: log_with_progress(
                    done,
                    total,
                    start_time,
                    prefix="candidates",
                    log_area=cand_log,
                    progress_bar=cand_progress,
                ),
                **_gc_kwargs,
            )
        except TypeError:
            # 戻り値の形 or 引数不一致（例: System4 の market_df）に対応
            if system_name == "System4" and spy_df is not None:
                ret = strategy.generate_candidates(
                    prepared_dict,
                    market_df=spy_df,
                    **kwargs,
                )
            else:
                ret = strategy.generate_candidates(
                    prepared_dict,
                    **kwargs,
                )
            if isinstance(ret, tuple) and len(ret) == 2:
                candidates_by_date, merged_df = ret
            else:
                candidates_by_date = ret
    # 正常系でも (dict, df) を返す実装があるため後段で正規化
    if isinstance(candidates_by_date, tuple) and len(candidates_by_date) == 2:
        candidates_by_date, merged_df = candidates_by_date
    try:
        cand_progress.empty()
    except Exception:
        pass

    if not candidates_by_date:
        st.warning(f"{system_name}: no candidates")
        return prepared_dict, None, None

    return prepared_dict, candidates_by_date, merged_df


# ------------------------------
# Backtest execution (common wrapper)
# ------------------------------
def run_backtest_with_logging(
    strategy,
    prepared_dict,
    candidates_by_date,
    capital,
    system_name: str = "SystemX",
    ui_manager=None,
):
    bt_phase = ui_manager.phase("backtest") if ui_manager else None
    if bt_phase:
        try:
            bt_phase.info("backtest: running...")
        except Exception:
            pass
        progress = bt_phase.progress_bar
        log_area = bt_phase.log_area
        debug_area = bt_phase.container.empty()
    else:
        st.info("backtest: running...")
        progress = st.progress(0)
        log_area = st.empty()
        debug_area = st.empty()
    start_time = time.time()
    debug_logs: list[str] = []

    # on_log は実装ごとにシグネチャが異なるため、可変長アダプターで受ける
    def _on_log_adapter(*args, **_kw):
        try:
            if len(args) == 3:
                i, total, _start = args
                msg = f"bt: {int(i)}/{int(total)} days"
            elif len(args) >= 1:
                msg = args[0]
            else:
                msg = ""
        except Exception:
            msg = str(args)
        try:
            if isinstance(msg, str) and msg.startswith("??"):
                debug_logs.append(str(msg))
            else:
                log_area.text(str(msg))
        except Exception:
            pass

    results_df = strategy.run_backtest(
        prepared_dict,
        candidates_by_date,
        capital,
        on_progress=lambda i, total, start: log_with_progress(
            i,
            total,
            start,
